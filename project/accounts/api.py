# Flask
from flask import jsonify

# Models
from project.models import Account
from project.accounts.accounts import create_account, generate_unique_iban


def api_create_account(account):

    # Title validation (existence, length, type) and error messages are automatically generated by swagger!
    title = account.get('title')
    if not title:
        return jsonify({"status": "error", "message": "This was unexpected. Swagger should have handled this..."}), 400

    new_iban = generate_unique_iban()

    status, message = create_account(new_iban, title) # Validates request data internally (given it is not None)

    if status == "success":
        account = Account.query.filter(Account.iban == new_iban).first()
        return jsonify({
                "status": "success",
                "message": message,
                "iban": account.iban,
                "title": account.title,
                "id": account.id
            }), 201
    else:
        return jsonify({"status": "error", "message": message}), 400




# def create(transaction):
#     transaction = dict(description=transaction.get("description"),amount=transaction.get("amount"), category=transaction.get("category"), date_booked=transaction.get("date_booked"))

#     # Validate request data
#     if transaction["description"] == None or len(transaction["description"]) > 80:
#         return jsonify({'error': 'Invalid or missing description'}), 400

#     if not isinstance(transaction["amount"], (int, float)):
#         return jsonify({'error': 'Invalid or missing amount'}), 400

#     if transaction["category"] not in ["Salary", "Rent", "Utilities", "Groceries", "Night out", "Online services"]:
#         return jsonify({'error': 'Invalid category value'}), 400

#     if transaction["date_booked"] != None and transaction["date_booked"] != "None":
#         try:
#             transaction["date_booked"] = datetime.fromisoformat(transaction["date_booked"].replace('Z', '+00:00'))
#         except:
#             return jsonify({'error': 'Could not convert date_booked to datetime object,'}), 400

#     # Create a new Transaction object
#     new_transaction = Transaction(**transaction)
#     db_session.add(new_transaction)
#     db_session.commit()
#     new_transaction.calculate_saldo()

#     # Return a success response
#     return jsonify({
#         'id': new_transaction.id,
#         'description': new_transaction.description,
#         'amount': float(new_transaction.amount),
#         'category': new_transaction.category,
#         'date_booked': new_transaction.date_booked.strftime('%Y-%m-%dT%H:%M:%SZ'),
#         'saldo': float(new_transaction.saldo)
#     }), 201
