## Imports
from flask import jsonify

from datetime import datetime
from flask import request

# Models
from project.models import Transaction, Account
from project.transactions.transactions import create_transaction

import re
import pytz

from project.transactions.transactions import TransactionError

## Custom exceptions
class DataValidationError(Exception):
    pass
class DateTimeFormatError(Exception):
    pass
class DateTimeConversionError(Exception):
    pass

## API Endpoints
def api_create_transaction(account_id):
    # Local imports to avoid import order error
    from project.accounts.accounts import AccountNotFoundError, validate_account

    try:
        account = validate_account(account_id)

        # Validate data from request body (which should technically be also validated by swagger)
        data = request.get_json()
        required_fields = ["description", "amount", "category"] # Description, account_id, amount, category validation and error messages are automatically generated by swagger!
        validate_data(required_fields, data)

        # Validate time booked format
        utc_datetime_booked = None
        if data.get("utc_datetime_booked") != None:
            utc_datetime_booked = validate_and_get_utc_datetime(data.get("utc_datetime_booked"))

        status, message, transaction_id = create_transaction(account=account,
                                                    description=data.get("description"),
                                                    amount=data.get("amount"),
                                                    category=data.get("category"),
                                                    utc_datetime_booked=utc_datetime_booked
                                                     )
        if status == "success":
            transaction = Transaction.query.get(transaction_id)
            return jsonify({
                "status": "success",
                "detail": "Successfully created new transaction.",
                "description": transaction.description,
                "amount": transaction.amount,
                "saldo": transaction.saldo,
                "transaction_id": transaction.id,
                "category": transaction.category,
                "utc_datetime_booked": f"{transaction.utc_datetime_booked.isoformat()}+00:00",
                "account_id": transaction.account.id
            }), 201
        else:
            return jsonify({"status": "error", "detail": message}), 400

    except AccountNotFoundError as ae:
        return jsonify({"status": "error", "detail": str(ae)}), 400
    except (DataValidationError, DateTimeFormatError, DateTimeConversionError) as e:
        return jsonify({"status": "error", "detail": str(e)}), 400

def api_create_subaccount_transfer(sender_account_id):

    # Local imports to avoid import order error
    from project.accounts.accounts import AccountNotFoundError, validate_account

    try:
        sender_account = validate_account(sender_account_id)

        # Validate data from request body (which should technically be also validated by swagger)
        data = request.get_json()
        required_fields = ["description", "amount", "recipient_account_id"] #validation and error messages are automatically generated by swagger!
        validate_data(required_fields, data)

        recipient_account = validate_account(data.get("recipient_account_id"))

        # Validate time booked format
        utc_datetime_booked = None
        if data.get("utc_datetime_booked") != None:
            utc_datetime_booked = validate_and_get_utc_datetime(data.get("utc_datetime_booked"))

        sender_transaction_id = api_process_sender_transaction(sender_account, data)
        recipient_transaction_id = api_process_recipient_transaction(recipient_account, data)

        if sender_transaction_id and recipient_transaction_id:

            transactions = transactions_to_json([Transaction.query.get(sender_transaction_id), Transaction.query.get(recipient_transaction_id)])

            return jsonify({
                "status": "success",
                "detail": "Successfully created subaccount transfer.",
                "transactions": transactions,
            }), 201
        else:
            return jsonify({"status": "error", "detail": "Something unexpected happened."}), 400

    except AccountNotFoundError as ae:
        return jsonify({"status": "error", "detail": str(ae)}), 400
    except (DataValidationError, DateTimeFormatError, DateTimeConversionError, TransactionError) as e:
        return jsonify({"status": "error", "detail": str(e)}), 400


## Subfunctions
def validate_data(required_fields, data):
    for field in required_fields:
        if data.get(field) is None:
            raise DataValidationError("This was unexpected. Swagger should have handled this...")

def validate_and_get_utc_datetime(datetime_string):
    pattern = re.compile(r'^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\+00:00$')
    match = pattern.match(datetime_string)
    if not match:
        raise DateTimeFormatError("utc_datetime_booked was not provided in the correct format.")
    try:
        utc_datetime_booked_string = datetime.fromisoformat(datetime_string)
        return utc_datetime_booked_string.replace(tzinfo=pytz.UTC)
    except:
        raise DateTimeConversionError("Could not convert utc_datetime_booked to datetime object")

def api_process_sender_transaction(account, data):
    """Process sender transaction and return its ID."""
    status, message, transaction_id = create_transaction(
        account=account,
        description=data.get("description"),
        amount=-data.get("amount"),
        category="Transfer"
    )
    if not transaction_id or status == "error":
        raise TransactionError(message)
    else:
        return transaction_id

def api_process_recipient_transaction(account, data):
    """Process recipient transaction and return its ID."""
    status, message, transaction_id = create_transaction(
        account=account,
        description=data.get("description"),
        amount=data.get("amount"),
        category="Transfer"
    )
    if not transaction_id or status == "error":
        raise TransactionError(message)
    else:
        return transaction_id

def transactions_to_json(transaction_list):
    json_transactions = []
    for transaction in transaction_list:
        transaction_dict = {
            "account_id": transaction.account.id,
            "transaction_id": (transaction.id),
            "amount": transaction.amount,
            "saldo": transaction.saldo,
            "description": transaction.description,
            "category": transaction.category,
            "utc_datetime_booked": transaction.utc_datetime_booked.isoformat()
        }
        json_transactions.append(transaction_dict)
    return json_transactions




# # Read all transactions
# def read_all():
#     return transactions_to_json(Transaction.query.all())

# # Read single transaction
# def read_one(id):
#     data = Transaction.query.get(id)
#     if data:
#         return transactions_to_json([data])
#     else:
#         abort(
#             404, f"Transaction with id {id} not found"
#         )
